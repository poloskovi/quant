// Решение упражнений из книги С.С.Сысоев "Введение в квантовые вычисления. Квантовые алгоритмы"

mod complex;
use complex::Complex;
mod qubit;
use qubit::Qubit;

extern crate matrix;

fn print_correct(qb: Qubit<f64>){
    if qb.is_correct(){
        println!("Это корректный кубит {}", qb);
    }else{
        println!("Кубит некорректен! {}", qb);
    }
}

// Состояние |φ> = (1-√2i)/4 |0> - (3-2i)/4 |1>
// измеряют в стандартном базисе |0>, |1>.
// Какова вероятность получить результат |1> ?
fn exercise_2_6(){

    println!("");
    println!("Упражнение 2.6");

    let sqrt2 = std::f64::consts::SQRT_2;

    let c1:Complex<f64> = Complex::new(1.0/4.0, -sqrt2/4.0);
    let c2:Complex<f64> = Complex::new(-3.0/4.0, 2.0/4.0);

    let q1 = Qubit::new(c1, c2);
    print_correct(q1);
    println!("вероятность нахождения в состоянии '1': {:.4}", q1.probability(1));
}

// Состояние |φ> = (1-√2i)/4 |0> - (3-2i)/4 |1>
// измеряют в базисе Адамара |+>, |->.
// Какова вероятность получить результат |+> ?
fn exercise_2_7(){

    println!("");
    println!("Упражнение 2.7");

    let sqrt2 = std::f64::consts::SQRT_2;

    let c1:Complex<f64> = Complex::new(1.0/4.0, -sqrt2/4.0);
    let c2:Complex<f64> = Complex::new(-3.0/4.0, 2.0/4.0);

    let q1 = Qubit::new(c1, c2);
    print_correct(q1);
    let qh1 = qubit::hadamar(q1);
    println!("после применения оператора Адамара: {}", qh1);
    println!("вероятность нахождения в состоянии '+': {:.4}", qh1.probability(0));

}

// Первый кубит состояния |φ> = 1/2 |00> - 1/2 |01> + 1/2 |10> + 1/2 |11>
// измерили в стандартном базисе и получили вектор |0>
// Какова вероятность при измерении второго кубита в базисе Адамара получить вектор |+> ?
fn exercise_2_10(){

    println!("");
    println!("Упражнение 2.10");

    // Решение: При измерении первого кубита исходное состояние переходит в [1/2 |00> - 1/2 |01>]
    // Домножаем каждую вероятность на 1/√2, чтобы получить корректное состояние (с полной вероятностью = 1)

    let sqrt2 = std::f64::consts::SQRT_2;

    let c1:Complex<f64> = Complex::new(1.0/sqrt2, 0.0);
    let c2:Complex<f64> = Complex::new(-1.0/sqrt2, 0.0);
    let q1 = Qubit::new(c1, c2);
    print_correct(q1);
    let qh1 = qubit::hadamar(q1);
    println!("после применения оператора Адамара: {}", qh1);
    println!("вероятность нахождения в состоянии '+': {:.4}", qh1.probability(0));

}

// Первый кубит состояния |φ> = (1+√3i)/4 |00> + (1-√3i)/4 |01> + (1-√3i)/4 |10> + (1+√3i)/4 |11>
// измерили в базисе Адамара и получили вектор |->
// Какова вероятность при измерении второго кубита в стандартном базисе, получить вектор |0> ?
fn exercise_2_11(){

//    println!("");
//    println!("Упражнение 2.11");

//    // Решение:
//    // 1. Переводим исходное состояние в базис Адамара

//    let sqrt3 = 3_f64.sqrt();
//    let c1:Complex<f64> = Complex::new(1.0/4.0, sqrt3/4.0);
//    let c1:Complex<f64> = Complex::new(1.0/4.0, -sqrt3/4.0);
//    let q1 = Qubit::new(c1, c2);

}

fn main() {

    exercise_2_6();
    exercise_2_7();
    exercise_2_10();

}
